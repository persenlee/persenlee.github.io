<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS展示3D模型及思考</title>
      <link href="2021/04/30/iOS%E5%B1%95%E7%A4%BA3D%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%80%9D%E8%80%83/"/>
      <url>2021/04/30/iOS%E5%B1%95%E7%A4%BA3D%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>3D模型在游戏中应用广泛，不过在电商App里的产品化应用并不多。目前能够看到的如<a href="https://ar.jd.com" target="_blank" rel="noopener">京东AR扫</a>、得物虚拟试穿、IKEA Place、淘宝人生等。应用不多的原因一方面是视频可以满足大部分3D显示的需求，另一方面3D模型生成还没有成熟的智能化方案。不过3D模型及在AR上应用是非常有前景的，对消费决策有很大的帮助。尤其像东家这样的美学电商平台，在玉石珠宝、文玩、家居、服饰、艺术品类目上会有很好的结合点。例如珠宝试戴、服饰试穿、文玩家居AR场景放置等等。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>demo演示的是一张床边桌子，以及可以切换4种不同的表面材质。<a href="https://www.cgtrader.com/free-3d-models/interior/bedroom/nightstand-6449d812-f58b-4500-97e8-44d061591899" target="_blank" rel="noopener">模型</a>来自于cgtrader。</p><p>模型的文件格式，需要注意Xcode兼容问题，参考👉<a href="https://developer.apple.com/documentation/modelio/mdlasset/1391813-canimportfileextension" target="_blank" rel="noopener">这里</a></p><p>推荐使用<a href="https://en.wikipedia.org/wiki/Universal_Scene_Description" target="_blank" rel="noopener">usdz</a>(Apple和<a href="https://en.wikipedia.org/wiki/Pixar" target="_blank" rel="noopener">Pixar</a>合作开发的3D文件格式)</p><p>这边下载的是<a href="https://zh.wikipedia.org/wiki/Wavefront_.obj文件" target="_blank" rel="noopener">obj</a> 文件，不要忘记一起下载<a href="https://people.sc.fsu.edu/~jburkardt/data/mtl/mtl.html" target="_blank" rel="noopener">.mtl</a>文件(材质库文件，描述的是物体的材质信息)及对应的材质资源。</p><p>如果在Xcode Scene Editor中无法显示预期的模型，这时候需要检查下.mtl文件里路径是否配置正确 以及 纹理贴图的模式是否正确。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>具体代码不在这里赘述了，参考👉<a href="https://github.com/persenlee/3DViewer" target="_blank" rel="noopener">这里</a></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p><img src="https://i.loli.net/2021/04/26/fcks5pETvzP8Mgt.gif" alt="iOS展示3D模型demo演示.gif"></p><h2 id="产品化思考🤔"><a href="#产品化思考🤔" class="headerlink" title="产品化思考🤔"></a>产品化思考🤔</h2><h3 id="3D模型生成"><a href="#3D模型生成" class="headerlink" title="3D模型生成"></a>3D模型生成</h3><p>3D模型如何高质量，批量化的生成对于业务落地是很关键一环，没有3D模型，巧妇难为无米之炊。</p><p>下面👇罗列了几种3D模型生成的方式和对应的优缺点，综合下来使用专业3D扫描仪获取3D模型数据 是比较好的一种途径，不过具体结果还需要实际验证。</p><ol><li>市面上有很多3D模型共享和交易平台，如<a href="https://sketchfab.com" target="_blank" rel="noopener">sketchfab</a>、<a href="https://www.turbosquid.com/Search/3D-Models/free" target="_blank" rel="noopener">tubosquid</a>、<a href="https://www.cgtrader.com/free-3d-models" target="_blank" rel="noopener">cgtrader</a>。可以获得一些测试用3D模型，不过产品化模型就无能为力了，除非通过交易定制化开发。</li><li>使用多张图片生成3D模型，如deepmind <a href="https://github.com/deepmind/deepmind-research/tree/master/polygen" target="_blank" rel="noopener">PolyGen</a>、adobe <a href="https://labs.adobe.com/projects/scantastic/" target="_blank" rel="noopener">Scantastic</a>、等，可以实现简单模型化、成本低、但还处于实验阶段。</li><li>专业的3d扫描仪，如<a href="https://www.creaform3d.com/en" target="_blank" rel="noopener">Creaform</a>、<a href="https://www.einscan.com" target="_blank" rel="noopener">Einscan</a>、等，获取高质量3D模型数据。</li><li>使用景深摄像头或LiDar的App，如shapr 3D、Qlone、Polycam、Scandy Pro，质量上难以保障。</li><li>通过测量数据，利用3D建模软件手动建模。这种方式成本极高、效率低。</li></ol><h3 id="模型分发"><a href="#模型分发" class="headerlink" title="模型分发"></a>模型分发</h3><p>基于<strong>PBR</strong>（物理光照）3D模型中往往包含高清的材质图片，因此模型大小基本都在几兆以上。</p><p>如果只是做单一商品的演示，可以把3D模型放在发行包里。</p><p>之后做规模化的应用就要考虑到模型分发的问题，</p><p>一种简单的解决方式使用Apple的<a href="https://developer.apple.com/augmented-reality/quick-look/" target="_blank" rel="noopener">AR Quick Look</a>集成到app或者h5页面直接预览AR模型，Android可以采用ARCore实现相同的功能。</p><p>另一种复杂但自主性更佳的方式，客户端需要支持一套模型资源下载，缓存，更新的策略。这里与图片的策略存在一定的差别。</p><p>至于服务端方面处理方式与图片、视频上传方式类似。</p><h3 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h3><p>Apple一直在AR方面深耕，ARKit从发布到现在ARKit 4、新的AR工具RealityKit，硬件方面也在加强从深感镜头、LiDAR、UWB定位（Airtag）、Airpods pro空间音频。</p><p>3D模型显示只是最基本的应用，犹如3D游戏一样。真正能让3D发挥更大能力就是AR与ML结合，创造出丰富的应用场景。现阶段的AR试穿、shapr 3D生成三维图纸。</p><p>结合东家与其他电商平台的情况，现阶段通过虚拟试穿，增强现实体验感、刺激消费者下单购买、降低退货率，是一种优质的服务。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/@litoarias/scenekit-to-show-3d-content-in-swift-5-5253afbe63b1" target="_blank" rel="noopener">https://medium.com/@litoarias/scenekit-to-show-3d-content-in-swift-5-5253afbe63b1</a></p><p><a href="https://juejin.cn/post/6844903532693291021" target="_blank" rel="noopener">https://juejin.cn/post/6844903532693291021</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift日志采集API</title>
      <link href="2021/03/31/Swift%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86API/"/>
      <url>2021/03/31/Swift%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86API/</url>
      
        <content type="html"><![CDATA[<p>在日常开发中，经常会遇到一些难以调试，无法重现的bug。使用日志采集API可以获得一些线索，帮助我们解决疑难杂症。</p><p>其实在iOS10就有相关API可以向日志系统发送信息，也就是os_log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#define os_log(log, format, ...)<br></code></pre></td></tr></table></figure><p>不过新版本API，提供了更加强大的能力。</p><h3 id="如何采集显示"><a href="#如何采集显示" class="headerlink" title="如何采集显示"></a>如何采集显示</h3><h4 id="终端命令行"><a href="#终端命令行" class="headerlink" title="终端命令行"></a>终端命令行</h4><p>连上设备后，执行log collect命令，收集完成后会在当前目录下生成一个.logarchive的文件，打开文件可以在Console应用中进行浏览</p><h4 id="Console（控制台）"><a href="#Console（控制台）" class="headerlink" title="Console（控制台）"></a>Console（控制台）</h4><p>连上设备后，打开Console应用，选中目标设备，就可以采集到相关日志并浏览</p><p><img src="https://i.loli.net/2021/04/07/KfWyCRcjMnqrwQ4.png" alt="WX20210331-215136@2x.png"></p><h3 id="强大的能力"><a href="#强大的能力" class="headerlink" title="强大的能力"></a>强大的能力</h3><h4 id="支持多种数据类型"><a href="#支持多种数据类型" class="headerlink" title="支持多种数据类型"></a>支持多种数据类型</h4><p>基于Swift的String的日志输出，String可以包含插入值，例如整形，浮点数，布尔类型，Objective-C对象，以及任何遵循<code>CustomStringConvertible协议的类型，甚至包括元类，如Int.self。</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> logger = <span class="hljs-type">Logger</span>() <span class="hljs-keyword">let</span> x = <span class="hljs-number">42</span> logger.info(<span class="hljs-string">"The answer is \(x)"</span>)<br></code></pre></td></tr></table></figure><h4 id="不同的日志级别，日志保留及性能"><a href="#不同的日志级别，日志保留及性能" class="headerlink" title="不同的日志级别，日志保留及性能"></a>不同的日志级别，日志保留及性能</h4><p>日志保留是指一条日志是否归档以及能否在app执行结束被取回，相反不被保留的日志，只能在app运行期间进行流式传输。</p><p>能否被保留是由日志等级决定的。</p><table><thead><tr><th align="left">日志等级</th><th align="left">描述</th><th align="left">日志保留</th></tr></thead><tbody><tr><td align="left">Debug</td><td align="left">只用在<strong>调试</strong>期间有用的信息上</td><td align="left">不保留</td></tr><tr><td align="left">Info</td><td align="left">用在故障排查有用但不是关键信息上</td><td align="left">日志采集命令（log collect）之前生成的消息会被保留</td></tr><tr><td align="left">Notice(default)</td><td align="left">对故障排除绝对有用的信息上，默认的日志等级</td><td align="left">被保留，有存储容量上限超过上限，旧消息会被清除</td></tr><tr><td align="left">Error</td><td align="left">记录运行期间的错误信息</td><td align="left">被保留，有存储容量上限超过上限，旧消息会被清除</td></tr><tr><td align="left">Fault</td><td align="left">记录由于潜在程序错误而引发的情况</td><td align="left">被保留，有存储容量上限超过上限，旧消息会被清除</td></tr></tbody></table><p>Erorr和Fault的日志等级，分别由黄色和红色气泡突出显示</p><p><img src="https://i.loli.net/2021/04/07/3gvjFMp7OBnCZha.png" alt="WX20210331-211546@2x.png"></p><p>性能与日志等级相关，Debug性能最块，Fault性能是最慢。这是由于Debug日志都不会被保留，如果日志不进行流式传输就会被废弃。</p><p>此外swift编译器对Debug日志做了复杂的优化。这就意味着你可以使用Debug级别日志记录详细的信息。</p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>日志在运行期间产生的原始数据，往往难以阅读。Log API 提供了格式化功能提高数据的可读性。并且可以将格式化后的数据拷贝到Numbers里做数据分析</p><h4 id="日志隐私"><a href="#日志隐私" class="headerlink" title="日志隐私"></a>日志隐私</h4><p>当应用下载安装到用户手机上时，日志记录仍会进行。只要把有安装该应用的设备使用线缆连接到电脑上，任何人都可以查看日志信息，所以有关个人信息的日志绝对不能被标记为 <code>.public</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift">logger.log(<span class="hljs-string">"Ordered smoothie \(smoothieName, privacy: .public)"</span>)  <span class="hljs-comment">// Visible </span><br>logger.log(<span class="hljs-string">"Paid with bank account \(accountNumber, privacy: .private(.hash))"</span>)  <span class="hljs-comment">// InVisible</span><br></code></pre></td></tr></table></figure><h3 id="API可用性"><a href="#API可用性" class="headerlink" title="API可用性"></a>API可用性</h3><p><img src="https://i.loli.net/2021/04/07/3P5Tah27QbJA1zF.png" alt="WX20210331-214452@2x.png"></p><p>之前的版本可以使用 os_log 进行替代。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.apple.com/videos/play/wwdc2020/10168/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2020/10168/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Protocol Buffers为什么能更小，更快</title>
      <link href="2020/05/23/Protocol-Buffers%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%9B%B4%E5%B0%8F%EF%BC%8C%E6%9B%B4%E5%BF%AB/"/>
      <url>2020/05/23/Protocol-Buffers%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%9B%B4%E5%B0%8F%EF%BC%8C%E6%9B%B4%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<p><code>Protobuf</code> 是一种非常高效的结构化数据存储格式，可用于通信协议数据传输，数据存储等领域。</p><p>这里说高效体现在序列化速度块，占用空间小，对数据结构描述简单且能够嵌套 并且能够向后兼容。</p><p>今天本文主要是想讨论为什么能更小，更快。当我们谈更小，更快的时候，隐含了与其他主流序列化方案的比较，主要是<code>json</code>和<code>xml</code>。众所周知<code>json</code>和<code>xml</code>有很多的分割符，例如json里 { } [] : 等，<code>Protobuf</code>序列化是没有这些分割符的，具体下面会讲到。另一方<code>xml</code>解析需要构建文档结构模型，这里涉及到词法分析，需要很多的cpu运算。<code>Protobuf</code>序列化大部分都是对二进制流进行位运算，相对会高效很多。这里的更小，更快本质是取决于<code>Protobuf</code>对encode/decode处理。</p><h2 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h2><p><code>Protobuf</code>  采用key-value pairs。</p><p>Key 用来标识具体的 field，在解包的时候，Protocol Buffer 根据 Key 就可以知道相应的 Value 应该对应于消息中的哪一个 field。</p><p>key的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(field_number &lt;&lt; <span class="hljs-number">3</span>) | wire_type<br></code></pre></td></tr></table></figure><p>field_number 是我们定义proto的field_id</p><p>wire_type类型如下</p><table><thead><tr><th align="left">Type</th><th align="left">Meaning</th><th align="left">Used For</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">Varint</td><td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td align="left">1</td><td align="left">64-bit</td><td align="left">fixed64, sfixed64, double</td></tr><tr><td align="left">2</td><td align="left">Length-delimited</td><td align="left">string, bytes, embedded messages, packed repeated fields</td></tr><tr><td align="left">3</td><td align="left">Start group</td><td align="left">groups (deprecated)</td></tr><tr><td align="left">4</td><td align="left">End group</td><td align="left">groups (deprecated)</td></tr><tr><td align="left">5</td><td align="left">32-bit</td><td align="left">fixed32, sfixed32, float</td></tr></tbody></table><h2 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h2><p>首先我们先要理解什么是<code>Varints</code>。<code>Varints</code>是一种用一个或多个字节序列化整数的方案，一些小的数字使用更少的字节。一般情况下一个Int类型为4bytes（与cpu和编译器相关），从统计的角度看，小的数字应用概率更多，所以4bytes会有很多bit是浪费掉。这时候<code>Varints</code>能起到很好空间利用。当然如果是大数，就需要多一个字节存储标志位了。</p><p>看标题128又是什么意思呢，<code>Protobuf</code>使用8bit的最高位做位标志位，即如果该位为1，表示后续的字节是这个数的一部分。如果是0表示数字结束。所以一个字节最大能表示128了，</p><p>下面我们看下例子，正整数300是用两个字节来表示：1010 1100 0000 0010</p><p>首先我们去掉标志位</p><p>010 1100 000 0010</p><p>Protobuf采用小端模式处理数据，需要换下顺序</p><p>000 0010  010 1100</p><p>移除高位0</p><p>1 0010 1100</p><p>最后计算结果</p><p>256 + 32 + 8 + 4 = 300</p><h2 id="有符号整数怎么办"><a href="#有符号整数怎么办" class="headerlink" title="有符号整数怎么办"></a>有符号整数怎么办</h2><p>根据上面<code>Varints</code>的编码，那负数怎么办？我们都知道，有符号整数也是用字节的最高位做位符号的标志位。即用一个大正整数表示负数。这时候用<code>Varints</code>表示负数就一定需要5个字节。<code>Protobuf</code>定义了sint32 sint64并且采用<code>zigzag</code>编码。使用<code>zigzag</code>编码 结合 <code>Varints</code> 能保证绝对值小的整数，采用较少的字节来序列化。</p><p><code>zigzag</code>编码处理如下</p><table><thead><tr><th align="left">Signed Original</th><th align="left">Encoded As</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">-1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">2</td></tr><tr><td align="left">-2</td><td align="left">3</td></tr><tr><td align="left">2147483647</td><td align="left">4294967294</td></tr><tr><td align="left">-2147483648</td><td align="left">4294967295</td></tr></tbody></table><p>对于sint32</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(n &lt;&lt; <span class="hljs-number">1</span>) ^ (n &gt;&gt; <span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>对于sint64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(n &lt;&lt; <span class="hljs-number">1</span>) ^ (n &gt;&gt; <span class="hljs-number">63</span>)<br></code></pre></td></tr></table></figure><p>这里很多人都会想到，既然字节的高位已经被当成<code>Varints</code>的标志位了，那有符号的标志位能不能放在次高位。这样做显然是可行的，但是这样不能做到如上效率最大化了，这样原先的不是那么大的数都要5个字节才能表示了。</p><h2 id="更多的类型"><a href="#更多的类型" class="headerlink" title="更多的类型"></a>更多的类型</h2><p><strong>非Varint编码数字</strong></p><p>例如double 及 fixed64 按原来的方式编码，不过wire type是5</p><p><strong>字符串</strong></p><p>含 字符串长度 + 字符串编码，字符串长度使用<code>Varints</code>编码</p><p><strong>嵌套消息</strong></p><p>处理方式与字符串类似</p><p><strong>其他</strong></p><p>参考中有说明</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/encoding</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HEIF图片格式入门</title>
      <link href="2020/04/24/HEIF%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
      <url>2020/04/24/HEIF%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%95%88%E7%8E%87%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">HEIF</a> 全称 High Efficiency Image Format ，是一种存储图片和图片序列的格式。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%95%88%E7%8E%87%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">HEVC</a> 全称High Efficiency Video Coding，是一种视频编码格式。</p><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p><img src="https://i.loli.net/2020/04/30/JLskQE954SV7DPi.jpg" alt="heif_container.jpg"></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><strong>高压缩比</strong></p><p>相同画质的情况下，HEIF容量不到JPG的一半</p><p><strong>高分辨率</strong></p><p>支持48bit色深，jpeg最大24bit<a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E6%B7%B1%E5%BA%A6" target="_blank" rel="noopener">色深</a>。人眼能看见数百万中颜色</p><p><strong>高扩展性</strong></p><p>HEIF是一种封装格式，除了保存缩略图，扩展信息（exif），原图数据外，还能保存其他任意信息，例如多张图片，音频等。</p><h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><p>后缀名大小写不敏感</p><table><thead><tr><th>Payload</th><th>Extension-single image</th><th>Extension-sequence</th></tr></thead><tbody><tr><td>HEVC</td><td>.HEIC</td><td>.HEICS</td></tr><tr><td>H.264</td><td>.AVCI</td><td>.AVCS</td></tr><tr><td>Any Codec</td><td>.HEIF</td><td>.HEIFS</td></tr></tbody></table><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><h4 id="苹果生态"><a href="#苹果生态" class="headerlink" title="苹果生态"></a>苹果生态</h4><h5 id="支持的硬件"><a href="#支持的硬件" class="headerlink" title="支持的硬件"></a>支持的硬件</h5><p>解码支持</p><table><thead><tr><th></th><th>iOS</th><th>macOS</th></tr></thead><tbody><tr><td>Hardware Decode</td><td>A9 Chip</td><td>6th Generation Intel Core</td></tr><tr><td>Software Decode</td><td>All iOS Devices</td><td>All Macs</td></tr></tbody></table><p>编码支持</p><table><thead><tr><th></th><th>iOS</th></tr></thead><tbody><tr><td>Hardware</td><td>A10 Fusion Chip</td></tr></tbody></table><h5 id="支持的系统"><a href="#支持的系统" class="headerlink" title="支持的系统"></a>支持的系统</h5><p>iOS11及以上</p><p>MacOS 10.13及以上</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>搭载 Android 10 的设备支持 HEIC 压缩图片格式</p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>开源的JavaScript库</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p><a href="https://blogs.windows.com/windowsexperience/2018/03/16/announcing-windows-10-insider-preview-build-17123-for-fast/#UpPIwc3yVgJHc5Q8.97" target="_blank" rel="noopener">Windows 10 (Build 17123)</a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>创建-查看-转码</p><h4 id="ImageIO"><a href="#ImageIO" class="headerlink" title="ImageIO"></a>ImageIO</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Read a heic image from file</span><br><span class="hljs-keyword">let</span> inputURL = <span class="hljs-type">URL</span>(fileURLWithPath: <span class="hljs-string">"/tmp/image.heic"</span>)<br><span class="hljs-keyword">let</span> source = <span class="hljs-type">CGImageSourceCreateWithURL</span>(inputURL <span class="hljs-keyword">as</span> <span class="hljs-type">CFURL</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">let</span> imageProperties = <span class="hljs-type">CGImageSourceCopyPropertiesAtIndex</span>(source, <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>) <span class="hljs-keyword">as</span>? [<span class="hljs-type">String</span>: <span class="hljs-type">Any</span>]<br><span class="hljs-keyword">let</span> image = <span class="hljs-type">CGImageSourceCreateImageAtIndex</span>(source, <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">let</span> options = [kCGImageSourceCreateThumbnailFromImageIfAbsent <span class="hljs-keyword">as</span> <span class="hljs-type">String</span>: <span class="hljs-literal">true</span>, kCGImageSourceThumbnailMaxPixelSize <span class="hljs-keyword">as</span> <span class="hljs-type">String</span>: <span class="hljs-number">320</span>] <span class="hljs-keyword">as</span> [<span class="hljs-type">String</span>: <span class="hljs-type">Any</span>]<br><span class="hljs-keyword">let</span> thumb = <span class="hljs-type">CGImageSourceCreateThumbnailAtIndex</span>(source, <span class="hljs-number">0</span>, options <span class="hljs-keyword">as</span> <span class="hljs-type">CFDictionary</span>)<br></code></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Writing a CGImage to a HEIC file</span><br><span class="hljs-keyword">let</span> url = <span class="hljs-type">URL</span>(fileURLWithPath: <span class="hljs-string">"/tmp/output.heic"</span>)<br><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> destination = <span class="hljs-type">CGImageDestinationCreateWithURL</span>(url <span class="hljs-keyword">as</span> <span class="hljs-type">CFURL</span>,<br><span class="hljs-type">AVFileType</span>.heic <span class="hljs-keyword">as</span> <span class="hljs-type">CFString</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">nil</span>) <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"unable to create CGImageDestination"</span>)<br><span class="hljs-type">CGImageDestinationAddImage</span>(imageDestination, image, <span class="hljs-literal">nil</span>) <span class="hljs-type">CGImageDestinationFinalize</span>(imageDestination)<br></code></pre></td></tr></table></figure><h4 id="PhotoKit"><a href="#PhotoKit" class="headerlink" title="PhotoKit"></a>PhotoKit</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// Editing a HEIF photo -- save as JPEG</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyPhotoFilter</span><span class="hljs-params">(<span class="hljs-number">_</span> filterName: String, input: PHContentEditingInput, output: PHContentEditingOutput, completion: <span class="hljs-params">()</span></span></span> -&gt; ()) &#123;<br><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> inputImage = <span class="hljs-type">CIImage</span>(contentsOf: input.fullSizeImageURL!) <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"can't load input image"</span>) &#125;<br><span class="hljs-keyword">let</span> outputImage = inputImage .applyingOrientation(input.fullSizeImageOrientation) .applyingFilter(filterName, withInputParameters: <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// Write the edited image as a JPEG.</span><br><span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.ciContext.writeJPEGRepresentation(of: outputImage,<br>to: output.renderedContentURL, colorSpace: inputImage.colorSpace!, options: [:])<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"can't apply filter to image: \(error)"</span>) &#125;<br>completion() &#125;<br></code></pre></td></tr></table></figure><h3 id="图片知识引申"><a href="#图片知识引申" class="headerlink" title="图片知识引申"></a>图片知识引申</h3><h4 id="位图与矢量图"><a href="#位图与矢量图" class="headerlink" title="位图与矢量图"></a>位图与矢量图</h4><p><strong>位图（vector image）</strong>：使用像素点阵列拼合的图像</p><p><strong>矢量图（raster image ,bitmap image）</strong>：通过数学公式计算获得的图形叫矢量图</p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>存储描述图片的参数，比如性质，内容，标题，地理位置，版权等，为方便数据库和文件系统调用。Exif（Exchangeable image file format）是被广泛接受的标准。</p><h4 id="常用图片格式"><a href="#常用图片格式" class="headerlink" title="常用图片格式"></a>常用图片格式</h4><p><strong>BMP（Bitmap）**</strong></p><p>windows系统下的标准位图格式，无压缩</p><p><strong>GIF（Graphics Interchange Format）</strong></p><p>支持动画图像，支持256色，对真彩图片进行有损压缩</p><p><strong>PNG（Portable Network Graphics）</strong></p><p>是一种<a href="https://zh.wikipedia.org/wiki/无损压缩" target="_blank" rel="noopener">无损压缩</a>的<a href="https://zh.wikipedia.org/wiki/位图" target="_blank" rel="noopener">位图</a>图形格式，支持索引、<a href="https://zh.wikipedia.org/wiki/灰度" target="_blank" rel="noopener">灰度</a>、<a href="https://zh.wikipedia.org/wiki/RGB" target="_blank" rel="noopener">RGB</a>三种颜色方案以及<a href="https://zh.wikipedia.org/wiki/Alpha通道" target="_blank" rel="noopener">Alpha通道</a>等特性。</p><p><strong>JPEG（Joint Photographic Experts Group)</strong></p><p>有损压缩，能达到较大压缩比</p><p><strong>JPEG 2000</strong></p><p><strong>TIFF（Tag Image File Format）</strong></p><p>用于传统影像印刷，可进行有损或无损压缩</p><p><strong>WEBP</strong></p><p>支持有损压缩、无损压缩、透明和动画</p><p><strong>HEIF</strong></p><p><strong>SVG（Scalable Vector Graphics）</strong></p><p>基于XML，由W3C联盟进行开发的可缩放的矢量图片</p><h4 id="常用格式比较"><a href="#常用格式比较" class="headerlink" title="常用格式比较"></a>常用格式比较</h4><p><img src="https://i.loli.net/2020/04/30/pWb2wZk3EvemSIL.jpg" alt="常用格式比较.jpg"></p><h4 id="选择合适的图片格式"><a href="#选择合适的图片格式" class="headerlink" title="选择合适的图片格式"></a>选择合适的图片格式</h4><p><img src="https://i.loli.net/2020/05/01/VA5fy6YLsIXWw8N.png" alt="图片格式选择.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/entry/5b2a244a6fb9a00e6a620cd6" target="_blank" rel="noopener">HEIF &amp; HEVC 你知道多少？</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2017/503/" target="_blank" rel="noopener">Introducing HEIF and HEVC</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2017/511/" target="_blank" rel="noopener">Working with HEIF and HEVC</a></p><p><a href="http://nokiatech.github.io/heif/#download" target="_blank" rel="noopener">High Efficiency Image File Format (HEIF)</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2019/419" target="_blank" rel="noopener">Optimizing Storage in Your App</a></p><p><a href="https://support.apple.com/zh-cn/HT207022" target="_blank" rel="noopener">在 Apple 设备上使用 HEIF 或 HEVC 媒体</a></p><p><a href="https://mp.weixin.qq.com/s/EUGLzI9aOui9CsXZHRusjA" target="_blank" rel="noopener">这个图像格式未来会统治你的设备</a></p><p><a href="https://source.android.com/devices/camera/heif" target="_blank" rel="noopener">HEIF 图片处理</a></p><p><a href="HEIF/heic图片文件解析">HEIF/heic图片文件解析</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter plugin开发</title>
      <link href="2019/03/08/flutter-plugin%E5%BC%80%E5%8F%91/"/>
      <url>2019/03/08/flutter-plugin%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Package分类"><a href="#Package分类" class="headerlink" title="Package分类"></a><strong>Package</strong>分类</h2><p><em>Dart packages</em></p><p><em>Plugin packages</em></p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">flutter create --org com.example --template=plugin hello <br><span class="hljs-meta">#</span><span class="bash">或者</span><br>flutter create --template=plugin -i swift -a kotlin hello<br></code></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="platform-channels"><a href="#platform-channels" class="headerlink" title="platform channels"></a><a href="https://flutter.dev/docs/development/platform-integration/platform-channels" target="_blank" rel="noopener"><strong>platform channels</strong></a></h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://i.loli.net/2020/05/01/1dEvMn4WS2bVRXJ.png" alt="MethodChannel架构.png"></p><h4 id="Channel分类"><a href="#Channel分类" class="headerlink" title="Channel分类"></a><strong>Channel</strong>分类</h4><p>BasicMessageChannel </p><p>MethodChannel </p><p>OptionalMethodChannel </p><p>EventChannel </p><p>具体参考【platform_channel.dart]</p><h4 id="MethodChannel"><a href="#MethodChannel" class="headerlink" title="MethodChannel"></a><strong>MethodChannel</strong></h4><p>name:unique<br> codec:【 StandardMessageCodec | JSONMessageCodec 】 invokeMethod|invokeListMethod|invokeMapMethod:dart invoke native </p><p>MethodCallHandler: native call dart</p><h4 id="参数支持的数据类型"><a href="#参数支持的数据类型" class="headerlink" title="参数支持的数据类型"></a>参数支持的数据类型</h4><p><img src="https://i.loli.net/2020/05/01/LkqxphSRfldscAe.png" alt="flutter plugin 参数支持.png"></p><h4 id="调⽤用结构图"><a href="#调⽤用结构图" class="headerlink" title="调⽤用结构图"></a>调⽤用结构图</h4><p><img src="http://assets.processon.com/chart_image/5c80b645e4b09a16b99944a1.png?_=1588294837162" alt=""></p><h4 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h4><p>pod </p><p>gradle</p><h2 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h2><p>项⽬文档</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CHANGELOG</span>.</span></span>md <br>LICENSE <br>API⽂文档(dartdoc)<br></code></pre></td></tr></table></figure><p>例子<a href="https://pub.dartlang.org/packages/quick_actions%23-readme-tab-" target="_blank" rel="noopener">quick_actions 0.3.0+1</a> </p><h2 id="发布Package"><a href="#发布Package" class="headerlink" title="发布Package"></a>发布Package</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">flutter packages pub publish --dry-run <br><br>flutter packages pub publish<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages" target="_blank" rel="noopener">https://flutter.dev/docs/development/packages-and-plugins/developing-packages</a> </p><p><a href="https://flutter.dev/docs/development/platform-integration/platform-channels" target="_blank" rel="noopener">https://flutter.dev/docs/development/platform-integration/platform-channels</a> </p><p><a href="https://juejin.im/post/5b84ff6a6fb9a019f47d1cc9" target="_blank" rel="noopener">https://juejin.im/post/5b84ff6a6fb9a019f47d1cc9</a> </p><p><a href="https://medium.com/flutter-io/flutter-platform-channels-ce7f540a104e" target="_blank" rel="noopener">https://medium.com/flutter-io/flutter-platform-channels-ce7f540a104e</a> </p><p><a href="https://github.com/flutter/flutter/wiki/The-Engine-architecture" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/The-Engine-architecture</a> </p><p><a href="https://juejin.im/post/5c3844fae51d4551ec60988e" target="_blank" rel="noopener">https://juejin.im/post/5c3844fae51d4551ec60988e</a> </p><p><a href="https://github.com/flutter/flutter/wiki" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki</a> <a href="https://cloud.tencent.com/developer/article/1366113" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1366113</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>django应用部署</title>
      <link href="2019/03/01/django%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"/>
      <url>2019/03/01/django%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-环境配置"><a href="#Python-环境配置" class="headerlink" title="Python 环境配置"></a>Python 环境配置</h2><p>激活python虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/venv/bin/activate<br></code></pre></td></tr></table></figure><p>退出虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">deactivate<br></code></pre></td></tr></table></figure><p>导出项目依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip freeze &gt; requirments.txt<br></code></pre></td></tr></table></figure><p>安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install -r ~/rainbow/rainbow_server/requirments.txt<br></code></pre></td></tr></table></figure><p>遇到Python.h: No such file or directory</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install python-devel<br></code></pre></td></tr></table></figure><h2 id="修改项目配置"><a href="#修改项目配置" class="headerlink" title="修改项目配置"></a>修改项目配置</h2><p>设置settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">DEBUG = <span class="hljs-literal">False</span><br>ALLOWED_HOSTS = [<span class="hljs-string">'公网ip'</span>]<br></code></pre></td></tr></table></figure><p>静态文件配置</p><p> setting.py 新增STATIC_ROOT</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">STATIC_ROOT=os.path.join(BASE_DIR,"static/")<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python manage.py collectstatic<br></code></pre></td></tr></table></figure><p>删除STATIC_ROOT</p><p>数据库迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python manage.py makemigrations<br>python manage.py migrate<br></code></pre></td></tr></table></figure><p>项目测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python manage.py runserver 0.0.0.0:8000<br></code></pre></td></tr></table></figure><p>如果是云服务器8000端口默认是不开放，需要修改网络安全组，测试完毕后需要改回去。</p><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><p>以下以mysql，若使用mariadb  替换即可</p><p>查看是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list installed mysql*<br></code></pre></td></tr></table></figure><p>查看是否安装过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list mysql*<br></code></pre></td></tr></table></figure><p>安装mysql客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install mysql<br></code></pre></td></tr></table></figure><p>启动/关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysqld start<br>service mysqld stop<br></code></pre></td></tr></table></figure><p>修改root密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -u root<br>use mysql;<br>update user set password&#x3D;password(&quot;123456&quot;) where user&#x3D;&quot;root&quot;;<br>flush privileges; <br>quit;<br></code></pre></td></tr></table></figure><p>修改默认字符集</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vi</span> /etc/my.<span class="hljs-keyword">cnf</span><br></code></pre></td></tr></table></figure><p>[mysqld]这行👆添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[client]  <br>default-character-set=utf8<br></code></pre></td></tr></table></figure><p>[mysqld]这行👇添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">default-storage-engine=INNODB  <br>character-set-server=utf8 <br>collation-server=utf8_general_ci<br></code></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database 数据库名;<br></code></pre></td></tr></table></figure><p>配置远程连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;<br>flush privileges;<br></code></pre></td></tr></table></figure><h2 id="配置uwsgi"><a href="#配置uwsgi" class="headerlink" title="配置uwsgi"></a>配置uwsgi</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install uwsgi<br></code></pre></td></tr></table></figure><p>检测是有安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uwsgi --http :8000 --module rainbow.wsgi<br></code></pre></td></tr></table></figure><p>其他正式配置文件</p><p>uwsgi.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><br><span class="hljs-comment"># 指定IP端口 </span><br><span class="hljs-comment">#http11-socket  = 127.0.0.1:8000 #测试用</span><br><span class="hljs-attr">socket</span>  = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8000</span><br><span class="hljs-comment"># 项目目录</span><br><span class="hljs-attr">chdir</span> =  /root/rainbow/rainbow_server<br><span class="hljs-attr">wsgi-file</span> = rainbow_server/wsgi.py<br><span class="hljs-attr">processes</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">threads</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">stats</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9191</span><br><span class="hljs-comment">#socket操作设置内部超时时间</span><br><span class="hljs-attr">socket-timeout</span> = <span class="hljs-number">60</span><br><span class="hljs-comment">#请求超时时间(&gt;=客户端设置的超时)</span><br><span class="hljs-attr">harakiri</span> = <span class="hljs-number">180</span><br><span class="hljs-comment">#请求超时日志</span><br><span class="hljs-attr">harakiri-verbose</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># 启动uwsgi的用户名和用户组</span><br><span class="hljs-attr">uid</span>=root<br><span class="hljs-attr">gid</span>=root<br><span class="hljs-comment">#退出、重启时清理文件</span><br><span class="hljs-attr">vacuum</span> = <span class="hljs-literal">true</span>      <br><span class="hljs-comment">#日志</span><br><span class="hljs-attr">daemonize</span> = /var/log/rainbow_uwsgi.log<br><span class="hljs-comment">#pid文件，用于脚本启动、停止uwsgi</span><br><span class="hljs-attr">pidfile</span> = /var/run/rainbow_test_uwsgi.pid<br></code></pre></td></tr></table></figure><p>使用参数启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uwsgi --http 127.0.0.1:8000 --wsgi-file rainbow_server/uwsgi.py<br></code></pre></td></tr></table></figure><p>上一个服务未关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef |grep uwsgi<br>kill -9 1234<br></code></pre></td></tr></table></figure><p>使用ini文件启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uwsgi --ini uwsgi.ini [&amp;]<br></code></pre></td></tr></table></figure><p>使用pid文件重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uwsgi --reload /var/run/rainbow_test_uwsgi.pid<br></code></pre></td></tr></table></figure><h2 id="配置ngnix"><a href="#配置ngnix" class="headerlink" title="配置ngnix"></a>配置ngnix</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install ngnix<br></code></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi rainbow_nginx.conf<br></code></pre></td></tr></table></figure><p>配置文件告诉nginx提供来自文件系统的媒体和静态文件，以及处理那些需要Django干预的请求</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># the upstream component nginx needs to connect to</span><br><span class="hljs-attribute">upstream</span> django &#123;<br>    <span class="hljs-comment"># server unix:/root/rainbow/rainbow_test.sock; # for a file socket</span><br>    <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8000</span>; <span class="hljs-comment"># for a web port socket (we'll use this first)</span><br>&#125;<br> <br><span class="hljs-comment"># configuration of the server</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># the port your site will be served on</span><br>    <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;<br>    <span class="hljs-comment"># the domain name it will serve for</span><br>    <span class="hljs-attribute">server_name</span> test.rainbowplanet.club; <span class="hljs-comment"># substitute your machine's IP address or FQDN</span><br>    <span class="hljs-comment">#https support</span><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">ssl_certificate</span> /etc/nginx/ssl/rainbow_test.crt;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /etc/nginx/ssl/rainbow_test.key;<br>    <span class="hljs-attribute">charset</span>     utf-<span class="hljs-number">8</span>;<br>    <br> <span class="hljs-attribute">server_tokens</span> <span class="hljs-literal">off</span>;<br>    <span class="hljs-comment"># max upload size</span><br>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">75M</span>;   <span class="hljs-comment"># adjust to taste</span><br> <span class="hljs-comment">#log</span><br>    <span class="hljs-attribute">access_log</span>      /var/log/nginx/rainbow_test.access.log;<br>    <span class="hljs-attribute">error_log</span>       /var/log/nginx/rainbow_test.<span class="hljs-literal">error</span>.log;<br>    <span class="hljs-comment"># Django media</span><br>    <span class="hljs-attribute">location</span> /media  &#123;<br>        <span class="hljs-attribute">alias</span> /root/rainbow/rainbow_server/media;  <span class="hljs-comment"># your Django project's media files - amend as required</span><br>    &#125;<br> <br>    <span class="hljs-attribute">location</span> /static &#123;<br>        <span class="hljs-attribute">alias</span> /root/rainbow/rainbow_server/static; <span class="hljs-comment"># your Django project's static files - amend as required</span><br>    &#125;<br> <br>    <span class="hljs-comment"># Finally, send all non-media requests to the Django server.</span><br>    <span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">60s</span>;<br>        <span class="hljs-attribute">client_body_timeout</span> <span class="hljs-number">20s</span>;<br>        <span class="hljs-attribute">uwsgi_send_timeout</span>   <span class="hljs-number">36s</span>;<br>        <span class="hljs-attribute">uwsgi_read_timeout</span>   <span class="hljs-number">36s</span>;<br>        <span class="hljs-attribute">uwsgi_connect_timeout</span> <span class="hljs-number">36s</span>;<br>        <span class="hljs-attribute">uwsgi_buffer_size</span>    <span class="hljs-number">512k</span>;<br>        <span class="hljs-attribute">uwsgi_buffers</span>     <span class="hljs-number">64</span> <span class="hljs-number">128k</span>;<br>        <span class="hljs-attribute">uwsgi_busy_buffers_size</span> <span class="hljs-number">1024k</span>;<br>        <span class="hljs-attribute">uwsgi_temp_file_write_size</span> <span class="hljs-number">512k</span>;<br>        <span class="hljs-attribute">uwsgi_pass</span>  django;<br>        <span class="hljs-attribute">include</span>   /root/rainbow/rainbow_server/uwsgi_params; <span class="hljs-comment"># the uwsgi_params file you installed</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>建立软连接,让nginx看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln -s /root/rainbow/rainbow_server/rainbow_nginx.conf /etc/nginx/conf.d/<br></code></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service nginx restart<br>// nginx reload<br></code></pre></td></tr></table></figure><p>static资源403问题</p><p>解决办法1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/nginx/nginx.conf<br>user root;<br></code></pre></td></tr></table></figure><h2 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h2><p>下载并启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install redis<br>redis-server<br></code></pre></td></tr></table></figure><h2 id="配置https"><a href="#配置https" class="headerlink" title="配置https"></a>配置https</h2><p>在nginx目录下创建证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir /etc/nginx/ssl/<br>sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /etc/nginx/ssl/rainbow_test.key -out /etc/nginx/ssl/rainbow_test.crt<br></code></pre></td></tr></table></figure><p>配置conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">listen 443 ssl;<br>ssl_certificate /etc/nginx/ssl/rainbow_test.crt;<br>ssl_certificate_key /etc/nginx/ssl/rainbow_test.key;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html" target="_blank" rel="noopener">https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/Django_and_nginx.html</a></p><p><a href="https://www.cnblogs.com/dingjiaoyang/p/5110546.html" target="_blank" rel="noopener">https://www.cnblogs.com/dingjiaoyang/p/5110546.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1156750" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1156750</a></p><p><a href="https://segmentfault.com/a/1190000004976222" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004976222</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aspects源码分析-如何实现AOP</title>
      <link href="2019/01/14/Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0AOP/"/>
      <url>2019/01/14/Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0AOP/</url>
      
        <content type="html"><![CDATA[<p>这篇文章谈是AOP，那什么是AOP呢，<strong>面向切面</strong>编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。那么以这个定义来看，Aspects是以Objective-C语言动态特性（runtime），在运行期添加程序功能来实现的。</p><p>从Aspects的使用方法来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(id)block<br>                            error:(NSError **)error;<br></code></pre></td></tr></table></figure><p>它可以实现对方法的切面，支持三种切面方式，使用block执行额外功能，以及hook失败的返回。</p><p>这时候抛出一个问题如果让你来设计，你是一个怎么样的思路。</p><p>我是这样考虑的，首先对方法切面的理解，显然我可以在程序任何地方多次进行的切面，那么这时候我们是需要有对切面进行描述的对象，并且把多次切面进行存储。其次对于block如何定义，这个block是实现selector额外的功能，那么从这个block我们能获取到和selector一样的上下文，即参数，self等。最后一个问题是调用selector的同时，如何调起你的切面。第一个会想到就是runtime  method-swizlling，问题也显而易见我们需要每个selector都要写个alias selector 进行替换，根本没Aspects这么通用。第二个会想到的就是Objective-C的消息转发机制，让被hook selector走消息转发，在forwardInvocation里插入额外的代码。其实Aspects就是以第二种方法来实现的。</p><p>那么接下去就分析Aspects如何实现切面的。</p><p>先看下Aspects是如何定义关于切面的信息的</p><p>1，切面selector信息的封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface AspectInfo : NSObject &lt;AspectInfo&gt;<br>- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;<br>@property (nonatomic, unsafe_unretained, readonly) id instance;<br>@property (nonatomic, strong, readonly) NSArray *arguments;<br>@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;<br>@end<br></code></pre></td></tr></table></figure><p>2，切面对象</p><p>包含切面selector，切面block，切面位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface AspectIdentifier : NSObject<br>+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;<br>- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;<br>@property (nonatomic, assign) SEL selector;<br>@property (nonatomic, strong) id block;<br>@property (nonatomic, strong) NSMethodSignature *blockSignature;<br>@property (nonatomic, weak) id object;<br>@property (nonatomic, assign) AspectOptions options;<br>@end<br></code></pre></td></tr></table></figure><p>3，切面容器</p><p>切面容器的作用是存储一个对象的一个方法中的所有切面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface AspectsContainer : NSObject<br>- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;<br>- (BOOL)removeAspect:(id)aspect;<br>- (BOOL)hasAspects;<br>@property (atomic, copy) NSArray *beforeAspects;<br>@property (atomic, copy) NSArray *insteadAspects;<br>@property (atomic, copy) NSArray *afterAspects;<br>@end<br></code></pre></td></tr></table></figure><p>4，切面跟踪器</p><p>这个切面跟踪器记录了一个对象中被切面所有方法，并且记录对象层次结构中其他切面跟踪器。可以想象这个追踪器跟对象层次树一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface AspectTracker : NSObject<br>- (id)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;<br>@property (nonatomic, strong) Class trackedClass;<br>@property (nonatomic, strong) NSMutableSet *selectorNames;<br>@property (nonatomic, weak) AspectTracker *parentEntry;<br>@end<br></code></pre></td></tr></table></figure><p>接下去看下aspect_add方法到底做了什么，</p><p>1，使用aspect_performLocked保证以下代码线程安全</p><p>2，校验selector能否被hook(具体哪些selector不能被hook，参考流程图)</p><p>3，获取切面容器并存储切面对象</p><p>4，获取被hook的class，动态生成子类并且hook  <code>forwardInovation</code>方法，这样保证消息转发的时候，能够执行额外代码。这里需要class相关的基本知识。</p><p>5，对hook selector新增alias selector保存原selector信息，将hook selector 的imp实现替换成<code>_objc_msgForward</code>/<code>_objc_msgForward_stret</code>  这样保证了hook selector能走消息转发。</p><p>流程图参考：</p><p><img src="http://assets.processon.com/chart_image/5c382dfee4b0f430adfe5e2a.png?_=1588239502392" alt="aspect_hook"></p><p>那么接下去只需要在forwardInvocation的hook方法里执行切面代码即可，</p><p>1，获取对应的切面容器</p><p>2，执行各个位置的切面，至于如何执行block，可以参考<a href="https://mikefighting.github.io/2018/07/04/advance-block-use-in-aspects/" target="_blank" rel="noopener">这篇文章</a></p><p>3，其他异常处理，执行原方法或者抛出<code>doesNotRecognizeSelector</code>异常。</p><p>最后看下切面的清理，具体看下流程图</p><p><img src="http://assets.processon.com/chart_image/5c383ba7e4b0641c83d8136f.png?_=1588239529630" alt="aspect_remove"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记BeeHive如何实现Annotation</title>
      <link href="2019/01/08/%E8%AE%B0BeeHive%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Annotation/"/>
      <url>2019/01/08/%E8%AE%B0BeeHive%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Annotation/</url>
      
        <content type="html"><![CDATA[<p>看如下的代码，我们可以通过 @BeeHiveMod 实现 DJHanFuModule 动态添加到beehive的模块管理器中。</p><p>如果不是用注解，我们需要通过配置文件DJModules.plist进行配置或者在应用启动的某个地方竟可能早的调用registerDynamicModule方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@BeeHiveMod(DJHanFuModule) <br>@interface DJHanFuModule : NSObject <br>@end<br></code></pre></td></tr></table></figure><p>这时候我们会有疑问 @BeeHiveMod 是如何将 DJHanFuModule 添加到beehive的模块管理器中，并且能够那么早的添加进去。</p><p>通过阅读源码，可以看到如下的宏起到了关键作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))  <br>#define BeeHiveMod(name) \ class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) &#x3D; &quot;&quot;#name&quot;&quot;; <br>#define BeeHiveService(servicename,impl) \ class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) &#x3D; &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;<br></code></pre></td></tr></table></figure><p>此时我们的关注点在__attribute,这个代码是什么用的，并且后面第二个参数，如果你知道mach-o文件格式，你应该会有感觉。</p><p>那什么是__attribute：</p><p><strong><code>__attribute__</code>是在C, C++, Objective-C语言中使用的编译指令，一般以<code>__attribute__(xxx)</code>的形式出现在代码中，方便开发者向编译器表达某种要求，参与控制如Static Analyzer、Name Mangling、Code Generation等过程。</strong></p><p>_attribute这个代码中参数</p><p>第一个参数<strong>used：</strong></p><p>这个参数是告诉编译器，我们定义的函数或者变量，即使没有被引用到，请编译器高抬贵手不要优化掉它，即删除掉。</p><p>第二个参数<strong>section</strong>：</p><p>通常情况下，编译器会将变量存储在mach-o文件的<strong>DATA某些段里，section能够让我们在</strong>DATA开辟新的数据段，来存储一些特殊的变量。</p><p>很显然BeeHiveMod 和  BeeHiveService 两个宏实现的功能即把用注解注释过的module 和 service 存储起来。</p><p>那么问题来了，beehive是怎么读取 以及 什么时候读取呢。</p><p>看如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">__attribute__((constructor)) <br>void initProphet() <br>&#123;     <br>  _dyld_register_func_for_add_image(dyld_callback); <br>&#125;<br>&#x2F;&#x2F;__attribute__ 可以实现constructor，而constructor是在class load完之后，main函数调用之前，dyld会调用这个方法。<br></code></pre></td></tr></table></figure><p>再看下_dyld_register_func_for_add_image 这个方法是可以在dyld 加载完image后调用dyld_callback回调，</p><p>这个回调函数定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)<br></code></pre></td></tr></table></figure><p>这时候我们可以获取到mach_header，然后通过getsectiondata就可以轻松地获取到之前通过注解存储的module 和 service了。</p><p>这时候注解注释过module 和 service 获取到了，我们就可以实现把module添加到beehive模块管理器中了。</p><p>后来我想了想是否可以通过其他方式实现同样的功能。</p><p>我想到的是将注解的module 和 service 存储到全局数组变量里，然后在AppDelegate  didFinishLaunchingWithOptions 方法中解析。这种方法与上述其实是类似的，全局变量是存储在mach-文件data段里。不过自己不需要实现section的读取。</p><p>最后使用__attribute实现anotation，也是比较巧妙的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式在iOS中的应用</title>
      <link href="2018/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2018/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：</p><p><strong>模式：在某些场景下，针对某类问题的某种通用的解决方案。</strong></p><p>场景：项目所在的环境</p><p>问题：约束条件，项目目标等</p><p>解决方案：通用、可复用的设计，解决约束达到目标。</p><h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><p>结构型模式：把类或对象结合在一起形成一个更大的结构。</p><p>行为型模式：类和对象如何交互，及划分责任和算法。</p><h1 id="iOS-具体应用"><a href="#iOS-具体应用" class="headerlink" title="iOS 具体应用"></a>iOS 具体应用</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (MotionOrientation *)sharedInstance &#123;     <span class="hljs-keyword">static</span> MotionOrientation *sharedInstance = <span class="hljs-literal">nil</span>;     <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;     <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;         sharedInstance = [[MotionOrientation alloc] init];     &#125;);     <span class="hljs-keyword">return</span> sharedInstance; &#125;<br></code></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义：定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 </p><p>描述：本质上是触发联动 </p><p>例子：notification/kvo</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">[[NSNotificationCenter defaultCenter] <span class="hljs-string">addObserver:</span>self                                              <span class="hljs-string">selector:</span><span class="hljs-meta">@selector</span>(<span class="hljs-string">onAppWillResignActive:</span>)                                                  <span class="hljs-string">name:</span>UIApplicationWillResignActiveNotification                                                <span class="hljs-string">object:</span>nil];<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">[_currentItem <span class="hljs-string">addObserver:</span>self <span class="hljs-string">forKeyPath:</span>@<span class="hljs-string">"status"</span> <span class="hljs-string">options:</span>NSKeyValueObservingOptionNew <span class="hljs-string">context:</span>nil];<br></code></pre></td></tr></table></figure><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 </p><p>描述：封装请求 </p><p>例子：target-action </p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>定义：为其他对象提供一种代理以控制对这个对象的访问。 </p><p>描述：代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象 </p><p>例子：使用NSProxy模拟多继承，delegate</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类 </p><p>描述：简单工厂，静态工厂，万能工厂 </p><p>例子：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">DJHomeRecommendBaseCell *cell = &#123;             [self.collectionView <span class="hljs-string">dequeueReusableCellWithReuseIdentifier:</span>key <span class="hljs-string">forIndexPath:</span>indexPath]         &#125;;<br></code></pre></td></tr></table></figure><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>定义：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活 </p><p>描述：本质上是动态组合 </p><p>例子：category/method swizzling/delegation </p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>定义：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 </p><p>描述：外观模式通过引入外观类，在类里定义简单的方法，然后在实现的方法里，再调用多个模块的功能。 </p><p>例子：访问接口返回的数据可能从服务端，缓存，数据库等获取 </p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>描述：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p>例子：Archiving/Serialization/<a href="https://www.raywenderlich.com/117471/state-restoration-tutorial" target="_blank" rel="noopener"><strong>State Restoration</strong></a></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 </p><p>描述：目的是复用已有的功能 </p><p>例子：Protocol</p><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>描述：一些方法通用，却在每一个子类都重新写了这一方法。将这些通用算法抽象出来</p><p>例子：DJBaseCollectionViewCell</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>描述：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p>例子：Router</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket协议及在东家中的应用</title>
      <link href="2018/08/31/WebSocket%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2018/08/31/WebSocket%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket背景"><a href="#WebSocket背景" class="headerlink" title="WebSocket背景"></a><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">WebSocket</a>背景</h2><p>早期，网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，只能通过<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>这种方式。轮询是指浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，之后服务器返回最新的数据给浏览器。轮询这种方式有一些不足之处，即浏览器需要不断的向服务器发出请求，然而HTTP请求与响应可能会包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，这样会消耗很多带宽资源。</p><p>比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术)" target="_blank" rel="noopener">Comet</a>。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>在这种情况下，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket使用<code>ws</code>或<code>wss</code>的<a href="https://zh.wikipedia.org/wiki/统一资源标志符" target="_blank" rel="noopener">统一资源标志符</a>（URI）。<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的WebSocket。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">ws://example.com/wsapi<br>wss://secure.example.com/wsapi<br></code></pre></td></tr></table></figure><p>WebSocket与HTTP和HTTPS使用相同的TCP<a href="https://zh.wikipedia.org/wiki/TCP/UDP端口列表" target="_blank" rel="noopener">端口</a>，可以绕过大多数<a href="https://zh.wikipedia.org/wiki/防火墙" target="_blank" rel="noopener">防火墙</a>的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。</p><h3 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h3><p>WebSocket 是独立的、建立在 TCP 上的协议。</p><p>Websocket 通过 <a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>/1.1 协议的101<a href="https://zh.wikipedia.org/wiki/HTTP状态码" target="_blank" rel="noopener">状态码</a>进行握手。</p><p>例子：</p><p><img src="https://i.loli.net/2020/04/30/1Xt3rWTNapvKqxo.png" alt="websocket数据帧.png"></p><p>例子使用<a href="https://github.com/joewalnes/websocketd" target="_blank" rel="noopener">websocketd</a>带的demo抓取的请求和响应。</p><h3 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h3><p><img src="https://i.loli.net/2020/04/30/f6MHnU7uDaJwkig.png" alt="websokcet握手.png"></p><p><strong>具体字段含义参考文末<a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener">连接</a></strong>这里不做过多缀述。</p><h2 id="WebSocket在项目中的应用"><a href="#WebSocket在项目中的应用" class="headerlink" title="WebSocket在项目中的应用"></a>WebSocket在项目中的应用</h2><p>东家app在WebSocket上做了丰富的场景落地，直播及拍卖的聊天室应用，私信（im）应用，全局长链接等。iOS采用<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SRWebSocket</a>，Android采用okhttp自带WebSocket</p><h3 id="握手请求头"><a href="#握手请求头" class="headerlink" title="握手请求头"></a>握手请求头</h3><p>这里与应用http框架的请求头保持一致即可</p><h3 id="序列化方案"><a href="#序列化方案" class="headerlink" title="序列化方案"></a>序列化方案</h3><p>我们采用的是<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protocol Buffers</a>，是因为相比于其他的序列化方案如json，xml。protobuf更快，更小，更简单。具体可以参考这篇博文《<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a>》</p><p>当然在使用protocol buffers 中也会遇到的一些问题，</p><ol><li>一个枚举定义的类型，后期新增类型值，老版本不能兼容。如果老版本解析未做异常处理，会导致crash。</li><li>注意编译的版本，前后端使用protobuf编译的版本要统一，否则也是无法解析的。目前我们是通过Jenkins编译不同语言pb文件，不需要拿源文件自己编译。所以可以很好的规避这个版本不一致的问题。</li></ol><h3 id="应用层心跳"><a href="#应用层心跳" class="headerlink" title="应用层心跳"></a>应用层心跳</h3><p>心跳用于检测与服务端的连接是否有效，影响连接主要以下因素。</p><ul><li>网络状态变化–手机网络和WIFI网络切换、网络断开和连上等情况有网络状态的变化，也会使长连接变为无效连接</li><li>NAT超时–大部分移动无线网络运营商在链路一段时间没有数据通讯时，会淘汰 NAT表中的对应项，造成链路中断。理想的情况下,客户端应当以略小于NAT超时时间的间隔来发送心跳包</li><li>DHCP租期–DHCP租期到了需要主动续约，否则会继续使用过期IP导致长连接偶然的断连；</li></ul><p>从WebSocket数据帧中有ping，pong两种操作码，我们可以通过它实现心跳。无需通过其他操作码自定义心跳。</p><p>可以采用定时发送心跳包，检测连接的有效性。</p><p>当然这里还可以进一步的优化，使用智能心跳策略。即心跳时间不是固定的，如果有响应消息可以推迟心跳。</p><h3 id="重连机制"><a href="#重连机制" class="headerlink" title="重连机制"></a>重连机制</h3><p>通过应用层心跳我们可以检测到连接的有效性，当我们失去连接的时候。客户端需要发起重连机制，同时也需要考虑给到业务层反馈。</p><h3 id="场景处理"><a href="#场景处理" class="headerlink" title="场景处理"></a>场景处理</h3><h4 id="应用前后台切换"><a href="#应用前后台切换" class="headerlink" title="应用前后台切换"></a>应用前后台切换</h4><p>iOS应用切换到后台，如果应用未开启后台常驻能力。长链接若干分钟后会被断开。之后应用切换到前台要考虑立即重新连接上。</p><h4 id="网络状态变化"><a href="#网络状态变化" class="headerlink" title="网络状态变化"></a>网络状态变化</h4><p>如果我们检测到当前网络不可用，这时候可以考虑取消掉心跳机制和重连机制，等到网络恢复后再恢复连接。这样可以减少cpu资源的浪费。</p><h4 id="用户登录状态变化"><a href="#用户登录状态变化" class="headerlink" title="用户登录状态变化"></a>用户登录状态变化</h4><p>这里考虑如果当前长连接与用户状态相关，当用户登录状态发生变化的时候是需要重连 或者 断开连接。</p><h4 id="请求缓存策略"><a href="#请求缓存策略" class="headerlink" title="请求缓存策略"></a>请求缓存策略</h4><p>有业务场景需要可以加上，当连接断开了，来自业务方一些请求如果不做缓存，这时候直接丢弃了。如果有缓存，能保证成功后第一时间发送出去。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455</a></p><p><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/WebSocket</a></p><p><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/websocket-deep-in.html</a></p><p><a href="https://www.xncoding.com/2017/05/03/web/websocket.html" target="_blank" rel="noopener">https://www.xncoding.com/2017/05/03/web/websocket.html</a></p><p><a href="https://caofengbin.github.io/2018/03/16/dhcp-and-nat/" target="_blank" rel="noopener">https://caofengbin.github.io/2018/03/16/dhcp-and-nat/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Xcode编译时间优化</title>
      <link href="2018/05/09/Xcode%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"/>
      <url>2018/05/09/Xcode%E7%BC%96%E8%AF%91%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Xcode-Build-Setting-Optimization-Level"><a href="#Xcode-Build-Setting-Optimization-Level" class="headerlink" title="Xcode Build Setting  Optimization Level"></a>Xcode Build Setting  Optimization Level</h2><p>关于<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/MOSXAppProgrammingGuide/Performance/Performance.html" target="_blank" rel="noopener">Optimization Level</a> 配置选项的含义点击标题链接查看。按照文档描述配置使用Fastest，编译代码速度会是最快的，然而测试效果并不理想，官方文档也不推荐此选项。</p><p>对于Pod工程每个target如何设置如下，目前Pod版本默认设置的Level是None</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><br>post_install <span class="hljs-keyword">do</span> <span class="hljs-params">|installer|</span><br><br>installer.pods_project.build_configurations.each <span class="hljs-keyword">do</span> <span class="hljs-params">|config|</span><br><br><span class="hljs-keyword">if</span> config.name.<span class="hljs-keyword">include</span>?(<span class="hljs-string">"Debug"</span>)<br><br> config.build_settings[<span class="hljs-string">'GCC_OPTIMIZATION_LEVEL'</span>] = ‘<span class="hljs-number">0</span><span class="hljs-string">'</span><br><span class="hljs-string"></span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">end</span><br></code></pre></td></tr></table></figure><h2 id="Xcode编译线程数设置"><a href="#Xcode编译线程数设置" class="headerlink" title="Xcode编译线程数设置"></a>Xcode编译线程数设置</h2><p>线程数与CPU的型号有关，目前Xcode默认设置线程数是4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>defaults write xcodebuild PBXNumberOfParallelBuildSubtasks 8 <br><br>defaults write xcodebuild IDEBuildOperationMaxNumberOfConcurrentCompileTasks 8 <br><br>defaults write com.apple.xcode PBXNumberOfParallelBuildSubtasks 8 defaults write com.apple.xcode IDEBuildOperationMaxNumberOfConcurrentCompileTasks 8<br></code></pre></td></tr></table></figure><h2 id="Build-Active-Architecture-Only"><a href="#Build-Active-Architecture-Only" class="headerlink" title="Build Active Architecture Only"></a>Build Active Architecture Only</h2><p>设置编译架构的版本,如果设置YES的话只编译当前活跃的架构，NO则为全部架构（armv7,armv7s,arm64)。</p><p>对于Pod工程如下配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><br>post_install <span class="hljs-keyword">do</span> <span class="hljs-params">|installer|</span><br><br> installer.pods_project.targets.each <span class="hljs-keyword">do</span> <span class="hljs-params">|target|</span><br><br> target.build_configurations.each <span class="hljs-keyword">do</span> <span class="hljs-params">|config|</span><br><br>      <span class="hljs-keyword">if</span> config.name == <span class="hljs-string">'Debug'</span><br><br>          config.build_settings[<span class="hljs-string">'ONLY_ACTIVE_ARCH'</span>] = <span class="hljs-string">'YES'</span><br><br>        <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Debug-Information-Format"><a href="#Debug-Information-Format" class="headerlink" title="Debug Information Format"></a>Debug Information Format</h2><p><a href="https://developer.apple.com/legacy/library/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW52" target="_blank" rel="noopener">Debug Information Format</a> 有三个选项，可选择如下两种</p><ul><li><a href="https://en.wikipedia.org/wiki/DWARF" target="_blank" rel="noopener">DWARF</a>(标准化调试数据格式)</li></ul><ul><li>DWARF with dSYM File</li></ul><p>一般Debug使用第一种，Release用第二种。</p><h2 id="二进制化"><a href="#二进制化" class="headerlink" title="二进制化"></a>二进制化</h2><p>二进制化是指我们的第三方依赖不使用源码这种形式，而是使用已编译好的静态链接库(.a)/动态链接库（framework)。</p><p>目前iOS开发依赖管理基本使用<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="noopener"><em>CocoaPods</em></a>，它是基于源码管理的。</p><p>也可以使用<a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener"><em>Carthage</em></a>，它是基于二进制来管理的。</p><p>目前CocoaPods也是可以配置二进制化<strong>cocoapods-packager</strong>，也可以自己实现<a href="https://www.zybuluo.com/qidiandasheng/note/595740" target="_blank" rel="noopener">Pod二进制化</a></p><p>其他工具例如：<a href="https://buckbuild.com" target="_blank" rel="noopener">Buck</a>，<a href="https://bazel.build" target="_blank" rel="noopener">Bazel</a></p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><ul><li>framework头文件导入多使用 @import，少用#import 。使用@import效率更好，安全性更好。</li></ul><ul><li>头文件中多用@class(预声明定义)，少用#import </li></ul><ul><li>删除无用代码及资源</li></ul><h2 id="ccahe"><a href="#ccahe" class="headerlink" title="ccahe"></a>ccahe</h2><p><a href="https://ccache.samba.org" target="_blank" rel="noopener">ccahe</a>是编译器缓存，Xcode自带的编译缓存在很多情况下回失效，导致编译时间有时候会很长。</p><h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>硬件加速主要是考虑多核性能加速和内存上的使用。这个不用多说，设备越好软件性能也会越好。</p><h2 id="分布式编译"><a href="#分布式编译" class="headerlink" title="分布式编译"></a>分布式编译</h2><p>对于本地工程没什么用，如果持续集成上的项目应该会有帮助。</p><h2 id="相关测试结果"><a href="#相关测试结果" class="headerlink" title="相关测试结果"></a>相关测试结果</h2><h4 id="xcode显示编译时间"><a href="#xcode显示编译时间" class="headerlink" title="xcode显示编译时间"></a>xcode显示编译时间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES<br></code></pre></td></tr></table></figure><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><p>处理器：2.7 GHz Intel Core i5 </p><p>内存：8 GB 1867 MHz DDR3 </p><p>目标项目： 东家</p><p>测试过程：pod update ,clean,build</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>| 相关操作                                                                      | 编译时间（s)  |</p><p>| ——————————————————————— | —————— |</p><p>| Optimization Level = None，线程数 = 4，全架构  | 608.897         |</p><p>| Optimization Level 设为Fastest                                | 683.089         |</p><p>| 编译线程数设为8                                                          | 581.908         |</p><p>| 单个架构(arm64)                                                          | 358.189         |</p><p>| ccache                                                                           |                        |</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/3b01979b2bf3" target="_blank" rel="noopener">如何加快XCode编译速度？</a></p><p><a href="https://www.zybuluo.com/qidiandasheng/note/587124" target="_blank" rel="noopener">如何加快编译速度</a></p><p><a href="https://bestswifter.com/improve_compile_speed/" target="_blank" rel="noopener">如何将 iOS 工程打包速度提升十倍以上</a></p><p><a href="https://www.jianshu.com/p/cd923dd1890a" target="_blank" rel="noopener">@import vs #import</a></p><p><a href="https://www.jianshu.com/p/53b2e3d203a9" target="_blank" rel="noopener">ccache 让你的编译时间飞起来</a></p><p><a href="https://juejin.im/post/59539377f265da6c415f064d" target="_blank" rel="noopener">[贝聊科技]如何将 iOS 项目的编译速度提高5倍</a></p><p><a href="https://www.zybuluo.com/qidiandasheng/note/595740" target="_blank" rel="noopener">Pod二进制化</a></p><p><a href="http://www.dzpqzb.com/2015/07/30/2015-07-30-fen-bu-shi-bian-yi-iosyan-jiu/" target="_blank" rel="noopener">分布式编译ios研究</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的转场实现及封装</title>
      <link href="2018/05/03/iOS%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%B0%81%E8%A3%85/"/>
      <url>2018/05/03/iOS%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="关于转场"><a href="#关于转场" class="headerlink" title="关于转场"></a>关于转场</h2><p>转场是两个<code>viewcontroller</code>切换之间发生的动画效果。iOS系统默认提供的转场效果像<code>UINavigationController</code> <code>push &amp; pop</code>效果，<code>UITabBarController</code> tab切换效果，以及模态弹窗<code>present &amp; dismiss</code>效果。目前转场有两种形式，普通转场 和 交互式转场（基于手势或者其他方式）。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>我们用<code>UINavigationController</code>举例子，<code>UINavigationControllerDelegate</code>有关转场有两个协议。</p><h3 id="普通转场"><a href="#普通转场" class="headerlink" title="普通转场"></a>普通转场</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (id&lt;UIViewControllerAnimatedTransitioning&gt;)<br>   navigationController:(UINavigationController *)navigationController <br>  animationControllerForOperation:(UINavigationControllerOperation)operation  fromViewController:(UIViewController *)fromVC <br>    toViewController:(UIViewController *)toVC;<br></code></pre></td></tr></table></figure><p>普通转场需要实现<code>UIViewControllerInteractiveTransitioning</code>协议的对象。<code>UIViewControllerInteractiveTransitioning</code>协议中需要实现两个核心方法，一个是返回转场时长，另一个提供转场上下文方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;<br><br>- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;<br></code></pre></td></tr></table></figure><p>我们需要重点了解<code>transitionContext</code>能给我们提供哪些必要信息。根据<code>UIViewControllerContextTransitioning</code>协议我们可以得到来源控制器（<code>fromViewController</code>）以及目标控制器（<code>toViewController</code>），来源视图（<code>fromView</code>）以及目标视图（<code>toView</code>），转场容器视图（<code>containerView</code>）。有这些上下文信息，已经足够实现动画了。</p><h3 id="交互式转场"><a href="#交互式转场" class="headerlink" title="交互式转场"></a>交互式转场</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController<br>                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController NS_AVAILABLE_IOS(7_0);<br></code></pre></td></tr></table></figure><p>交互式转场需要实现  <code>UIViewControllerInteractiveTransitioning</code>协议的对象，该协议核心方法是</p><p><code>\- (void)startInteractiveTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</code>。我们一般不自己实现<code>UIViewControllerInteractiveTransitioning</code>协议，而是使用系统提供的已实现该协议的类<code>UIPercentDrivenInteractiveTransition</code>。<code>UIPercentDrivenInteractiveTransition</code>方便之处在于它可以基于普通转场实现交互式转场。而你需要做的是在转场过程中更新转场进度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其他两种形式的转场实现方式与上面类似。</p><p>对于模态窗需要实现<code>UIViewControllerTransitioningDelegate</code>中四个关于转场的协议。</p><p>对于<code>UITabBarController</code>需要实现<code>UITabBarControllerDelegate</code>中两个关于转场的协议。</p><h2 id="关于封装"><a href="#关于封装" class="headerlink" title="关于封装"></a>关于封装</h2><p>按照上面实现方式，我们会发现若干个问题。</p><ul><li><p>每一个实现<code>UIViewControllerAnimatedTransitioning</code>协议对象，都需要从转场上下文获取对应的信息，这些代码都是相同的，唯一真正的不同在于动画部分。</p></li><li><p><code>ViewController</code>中实现转场相关的代理，在代码中过于分散。</p></li></ul><p>根据上面存在的问题封装了库<a href="https://github.com/persenlee/PLTransition" target="_blank" rel="noopener">PLTransition</a>，具体一些例子效果如下。</p><p><img src="https://i.loli.net/2020/04/30/hCWnQFGvZBYoO7j.gif" alt="GIF图像-8124270787A5-1.gif"></p><p><img src="https://i.loli.net/2020/04/30/kErLIupNjmgPl5c.gif" alt="GIF图像-4543B455C1B7-1.gif"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>转场可以与CoreImage，CoreAnimation 结合生成很多酷炫交互效果，可以看看这个库<a href="https://github.com/shu223/AnimatedTransitionGallery" target="_blank" rel="noopener">AnimatedTransitionGallery</a>实现的一些效果。</p></li><li><p>如何将封装的库应用到具体项目里，还是有很多改进的地方。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
